Code outline for basic GA neuroevolution:

Main function:
Takes parameters as inputs (pop size, mutation rates, fitness function? etc)
    Create N new genomes through some randomization
    Give fitness ranking to each in first gen
    For G generations run:
        rank all in current gen by fitness
        Make N-1 new genomes by randomly selecting one of T top parents, then mutating
        Take top 10 individuals from last gen:
            run fitness on each 30 times, take mean for new fitness
            take highest fitness of these, add to new gen
    Print last gen into file?
    return best genome


Issues to consider:
    Should tensors be float or double? Is there a significant cost to double?


Params to fiddle with:


1534 seconds for 1 gen on cuda, cpu use around 17-20% average, 960mb
1344 seconds for 1 gen on cpu, cpu use around 50%, 80mb

frostbite gpu:
11710 in evalFitness
776 in forward
3937 in atari step; 32 total (mostly waiting?)
ale_python_interface: ~3700 seconds, twice?

frostbite cpu:
4383 in evalFitness
342 in forward
3600 total in ale

venture cpu
13790 evalFitness
10800 ale


Notes:
Should list dependencies/installs in readme
pytorch torchvision, gym, gym[atari]

Ways to speed up:
Improve ALE use? (or fewer steps?)
Repeat tests to see if evalFitness itself is actually an issue; if so:
    try reworking action selection
    make env attached to genome? (no rebuilding each time)
    
    
More gpu times:

Frostbite:
1368 total, some in input/waiting
444 seconds in make? Might be calls to load ROM (502 calls, so yes)
1285/236 in evalFitness
443 ALE load ROM -only 502 calls; try to find/reduce these?
453 ALE step (act?)
19 on reset
236 + 443 + 453 + 19 = 1151 of evalFitness; also 66 in forward, only 68 unaccounted

Frostbite with envs created when genome is (only reset on evalFitness)
1456 total, some in waiting (less?)
1393/241.5 in evalFitness (slightly better?)
79 in forward
21 on reset
474 on ALE ROM
493 on ALE act

As above, but now envs copied from parent in mutation (maybe faster?)
928/242 in evalFitness
84 in forward
97 on ROM (no longer in eval)
493 on Act
23.5 on reset
242 + 84 + 97 + 493 + 23.5 = 876.5 in evalFitness, 51.5 unaccounted (find this- mayb just torch making/moving tensors?)
This is much faster and better; only concern is how much memory this takes up with a larger population (each env is kept in RAM the whole time now)
Not sure if I can improve ALE act at all... but where is the evalFitness bottleneck?!
options:
    use floats as torch default for everything here
    random action select to deterministic based on greatest value
    Could wrap each part of evalFitness in a sub-function, so cProfile points more directly to the issue

Next attempt:
5744/2026 in evalFitness??
447 on forward
2645 on Act
99 on ROM
24 on reset
seems pretty off

***ReLU before or after bias is added? Also, allow bias added to first layer?
Fix naming convetion for classes (Genome_network??)
!***Do I even need more than 1 env per thread? Do genomes need their own env?
Also, should the experiment carry the env var? makes things a little easier...


ssh poppelee@fries.reed.edu
scp -r mydir poppelee@fries.reed.edu:
nohup my process > results.txt
tmux

warning that scripts futurize and pasteurize are not installed on PATH (and convert-caffe2-to-onnx and vcvsa)--What was this error from again?

For NEAT, I am skipping the ability to re-enable genes; currently old genes are deleted. I don't think this will have a great impact; also it looks like re-enabling must be pretty conditional, as it doesn't make so much sense in the given examples (or maybe it does? page 12, 5->4 doesn't make much sense, I think...)

basic_evolve --> evolve_basic to keep with m.t. convention and make things clear

NEAT evolution is working, but highly favors basic architecture
Two things possibly going wrong: crossover not adding disjoint/excess correctly, or mutations screwing something up and making fitness much worse (affecting the network more than they should)
Test first with some crossover test, test second by observing tensors/model of mutated network

Thesis first/second chapter outline:
Abstract
Intro:
    Outline of problem/question
Intro to ML:
    basics
    neural nets
    traditional methods of training (SGD)
Intro to GAs:
    concept
    applications
Intro to Neuroevolutuion
    basics
    why its useful/applications
    quick history of innovations/algorithms
Lit review:
    various flavors of NEAT and their uses
    recent applications of non-NEAT algorithms
    other recent work?
    specific areas/problems: where NE seems better than SGD, where it's promising, where it falls short
    details on the uber paper
Statement of my problem:
    use uber paper as benchmark
    replicate code and recreate neat, apply to same problems
    after comparison, further investigation of more successful methods
    ideal: produce some variation/innovation that outperforms the uber results (or NEAT, if NEAT is better at the start)



NEAT:
how to control network size?
shrinking network operator?
disabling connections and nodes
run on XOR


Work on multithreading:
    I have figured out the issue with my previous attempts was that I was trying to pipe too much data across the whatnot
    So now I no longer am moving nets through the queue, since that broke the pipes
    Instead, nets are copied over only when a process is made, and then evalFitness is the only thing done on the thread
    The return value is just the fitness from the experiment, which is then assigned to the corresponding net in the main thread
    At first I made a thread for each net and did them all at once
    This was, unsurprisingly, a terrible idea
    Now I loop through the process several times with a maximum thread count
    CUDA might still not work. I am hoping it is functional as long as I don't try to pipe and CUDA-assigned memory around
    So I think the plan is then to keep all nets on CPU, then move them to GPU only in the evalFitness
    And hopefully moving to GPU from another thread is fine? But idk what to do if/when this fails

To add from NEAT paper:
    disable connections instead of removing
    explicit fitness sharing
    actual speciation (distinct species) rather than distance testing upon crossover
    use top percent of each species rather than top overall
    check how connections are re-enabled (longer paper)

Currently:
    species is done except for fitness sharing
    Run a few times to fix bugs, then add the sharing
    then add connection disable/re-enable methods
    then smooth out MT and clean code
    After that and some extensive testing/comparing results, I think this is ready for improvements/research?

Changes to make:
Remove species if max fitness did not improve in 15 generations
elite carrover for top of all species of 5 or greater pop
chance that weight mutation will reset to new value instead of being perturbed
also add re-enable chance
replace ReLU with sigmoidal?
-------------------------

!! Find initial values and mutation effect? couldn't find in paper so borrowing from pytorch neat implementation


    Try XOR ASAP

    improve multithreading to whatever is fastest
Reorg:

    maybe restructure species as a subclass of population and inherit as much as possible


Important Issue:
    Paper's phrasing is somewhat ambiguous about whether disabled connections are counted in E and D or just in W
    (regarding the equation on page 13 (110) of the longer paper)
    at present I have this just implemented in W since that's my guess (and also less work)





